# IS_IA-136-152-153

# Introduction

Python for CyberSecurity functions includes malware analysis, scanning, and penetration testing tasks, has become an industry standard.CyberSecurity engineers need to have an agile approach to testing and evaluating the security of the applications under their responsibility. As a language, Python is user-friendly and has an elegant simplicity, making it the language of choice for many security engineers.

# We have built a collection of simple Python scripts  for security testing.

# The first functionality is

# PORT SCANNING
A port scanner is an application which is made to probe a host or server to identify open ports. Bad actors can use port scanners to exploit vulnerabilities by finding network services running on a host. They are used by security analysts to confirm network security policies.
The first test we’ll execute looks for different ways to infiltrate the target system. We do this by scanning for open ports using a script like portScanner.py. An open port can provide an ingress point if we can determine what type of traffic the target machine is expecting on that port. We’ll be using sockets to test for connection, and a threaded model to speed up the process.
We have set our thread pool at 500 concurrent requests and checked every port up to 10,000. We include these as constants to make them easy to change.If we execute this script, we’ll see which ports on the target machine are listening and potentially vulnerable for an exploit.We ran it against our own ip address and these are the available ports.The second functionality we implement is packet sniffing

# Packet sniffing:
It is the process of capturing all the packets flowing across a computer network. The sniffed packets give away a lot of information like what website a user visits, what contents does the user see, what does the user download and almost everything. The captured packets are usually stored for future analysis.Packet sniffing is essentially putting a wiretap on a system. We used a tool like Wireshark.We have used php to login the user and then monitor the details of the packets using wireshark.Here wireshark and php go hand in hand.

# The third functionality we implement is TCP Packet Injection:
Once we can sniff out web packets from one device to another, we can build out packets that have the same headers and insert updated or malicious information into the packet using a script like packetInjection.py. Some examples that use this approach include denial-of-service and man-in-the-middle attacks. Intercepting and manipulating the contents of packages discreetly at the edge of a network to prevent or adjust the flow of information can also be done.

We’ve kept this example very simple and built an ICMP packet, such as what would be sent when you send a ping, or initiate a connection to a remote device. We’ll use the diagram below to understand the structure of an ICMP packet and build our packet accordingly.The MAC header consists of the source and destination MAC addresses, and we’ll let the socket add these when the script sends the packet. We’ll add the IP header and the ICMP header. The IP header consists of 2 Bytes, the first represents the protocol type; and then second, the code. We’ll set the type to 8, which is the EGP type code we talked about above. We’ll set the code to 0, which sends a clear field.The ICMP header has a checksum, an identifier, and a sequence number. The checksum is calculated based on the size of the package. We’ll set this to 0, and then calculate the size after we compile the package. The packet recipient uses the checksum value to verify that the package contents haven’t been tampered with or corrupted during transport. The identifier is a unique identifier for the packet, we’ll use a random number generator for this, and we’ll set the sequence to 1, indicating that it is the first packet in the sequence. In our case, the sequence contains a single packet.Finally, we’ll open a socket and use it to send the packet to a remote machine. We’re sending this to 192.168.29.133:80, which is a machine on our network running an Apache Web Server. We started the packet-sniffing script we created above in a different window so that we could observe the traffic.The scripts above provide some elementary examples of ways in which one can leverage the elegant simplicity of Python to validate the security of applications or expose weaknesses for the team to fix before proceeding with deployment. We conclude our study on Security tools here.
